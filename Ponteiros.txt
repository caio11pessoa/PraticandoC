Aula 1 - Introdução Ponteiros
8 bits = 1byte
1024 bytes = 1kilobyte
1024 kylobytes = 1 megabyte
1024 megabytes = 1 gigabyte


1 bit = 0 ou 1 (menor espaço de memória possível no computador)

int x; -> o compulidor vai na memória do computador, procura um espaço armazenável que contenha espaços necessários para se armazenar um inteiro

existe uma diferença entre valor que está contido na memória do meu computador e o endereço onde está contido esse valor
o endereço de memória é o inicial

ponteiros utiliza os endereços de memória
-> altera o valor que está nesse endereço específico

& -> indica o endereço da memória que contém a variável em questão

o ponteiro precisa saber que tipo de dado ele vai estar apontando, int, char, etc...

int *ponteiro; //criado um ponteiro que está apontando para algum inteiro(sendo declarado)
ponteiro = &x


*ponteiro -> valor
a ponteiro -> endereço de memória
AULA 03 - ponteiro "char, int, double" - Aula 62

    	int *pX;//Declarando o ponteiro, usa-se o *

    	pX = &x;//Passando para o ponteiro o endereço de memória de x, usa-se o &
	o endereço desse ponteiro, está apontando ao endereço de x

	int *pX = &x;//Declarando e atribuindo na mesma linha


	*pX = alguma coisa
	o valor que *pX está apontando será atribuído a alguma coisa

quando colocamos o ponteiro dessa maneira pX, queremos nos referir ao local da memória que ele está apontando
quando colocamos o ponteiro dessa maneira *pX, queremos nos referir ao valor que está armazenado no lugar da memória em que ele está apontando

Os ponteiros podem ser usados para realizar operações matemáticas, desde que se utilize o *

ex    	double soma = *pX + *pY;

se retirar os * vai dar um erro, pois o compilador vai estar tentando somar dois endereços de memória, o que não é possível

pode ser atribuído diretamente um endereço de memória a um ponteiro

int *ponteiro;
ponteiro = 232144;//acredito que não seja aconselhado

AULA 04 - Ponteiros à Estruturas - Aula 63

#include <stdio.h>
#include <stdlib.h>

int main()
{
    struct horario{
        int hora;
        int minuto;
        int segundo;
    };

    struct horario agora, *depois;
    depois = &agora;

    (*depois).hora = 20;// o ponto tem preferência
    (*depois).minuto = 20;
    (*depois).segundo = 20;

    printf("%i:%i:%i\n", agora.hora, agora.minuto, agora.segundo);

    depois->hora = 40;
    depois->minuto = 40;
    depois->segundo = 40;

    printf("%i:%i:%i", agora.hora, agora.minuto, agora.segundo);
    getchar();

    return 0;
}

- Declarando um tipo de estrutura
struct horario{
        int hora;
        int minuto;
        int segundo;
    };


- Declarando uma estrutura do tipo horario e um ponteiro de estrutura
    struct horario agora, *depois;
    depois = &agora;

- Uma maneira de manipular um ponteiro de estrutura
    (*depois).hora = 20;// o ponto tem preferência
    (*depois).minuto = 20;
    (*depois).segundo = 20;
//O parênteses é necessário pois o ponto tem preferência em relação ao *

- Outra maneira de manipular um ponteiro, usando o ->
    depois->hora = 40;
    depois->minuto = 40;
    depois->segundo = 40;

dessa maneira não precisa colocar nem o ponto, nem o asterísco nem os parênteses

AULA 05 - Ponteiros à Estruturas(Operações Matemáticas) - Aula 64

    antes.hora = somatorio + depois->segundo;
    antes.minuto = agora.hora - depois->minuto;
    antes.segundo = depois->minuto + depois->segundo;

antes é uma estrutura do tipo horario, como o do exemplo anterior

utiliza-se o -> para expressar o valor armazenado no local em que o ponteiro está apontando na memória
	depois->segundo;

AULA 06 - Programar em C - Estruturas que contêm Ponteiros - Aula 65

#include <stdio.h>
#include <stdlib.h>

int main()
{
    struct horario {
        int *pHora;
        int *pMinuto;
        int *pSegundo;
    };

    struct horario hoje;

    int hora = 200;
    int minuto = 300;
    int segundo = 400;

    hoje.pHora = &hora;
    hoje.pMinuto = &minuto;
    hoje.pSegundo = &segundo;

    printf("hora - %i\n", *hoje.pHora );
    printf("minuto - %i\n", *hoje.pMinuto );
    printf("segundo - %i\n", *hoje.pSegundo );

    *hoje.pSegundo = 1000;
    printf("segundo - %i\n", *hoje.pSegundo );

    getchar();
    return 0;
}

- Declarando ponteiros dentro de estruturas
    struct horario {
        int *pHora;
        int *pMinuto;
        int *pSegundo;
    };

- Mostrando para onde esses ponteiros dentro das estruturas estão apontando

    hoje.pHora = &hora;
    hoje.pMinuto = &minuto;
    hoje.pSegundo = &segundo;

- Printando os valores que estão armazenado no local da memória onde esses ponteiros apontam

    printf("hora - %i\n", *hoje.pHora );
    printf("minuto - %i\n", *hoje.pMinuto );
    printf("segundo - %i\n", *hoje.pSegundo );

- Alterando o valor contido no local da memória onde esses ponteiros apontam

    *hoje.pSegundo = 1000;


Aula 07 -  Passar Ponteiro Como Parâmetro de Uma Função - Aula 66

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    void testeVariavel(int x);//uma cópia da variável teste está sendo feita
    void testePonteiro(int *pX);//Neste caso o parâmetro está sendo passado por referência
    int teste = 1;
    int *pTeste = &teste;

    testeVariavel(teste);
    printf("%i\n", teste);

    testePonteiro(pTeste);//Não escreve * nesse caso, pois a função recebe um endereç de memória
    printf("%i\n", teste);
    getchar();

    return 0;
}
//uma cópia da variável teste está sendo feita
void testeVariavel(int x){
    ++x;
}
void testePonteiro(int *pX){
    ++*pX;
}

- Declarando funções

    void testeVariavel(int x);//uma cópia da variável teste está sendo feita
    void testePonteiro(int *pX);//Neste caso o parâmetro está sendo passado por referência

- Passando um ponteiro como parâmetro de uma função

void testePonteiro(int *pX){
    ++*pX;
}

- Chamando a função com o Ponteiro

    testePonteiro(pTeste);//Não escreve * nesse caso, pois a função recebe um endereç de memória
 
Aula 08 - Lista Concatenada - Aula 68

#include <stdio.h>
#include <stdlib.h>

int main()
{
    struct lista {
        int valor;
        struct lista *proximo;
    };
    struct lista m1, m2, m3;
    struct lista *gancho = &m1;

    m1.valor = 10;
    m2.valor = 20;
    m3.valor = 30;

    m1.proximo = &m2;
    m2.proximo = &m3;
    m3.proximo = (struct lista *)0;//fecha a lista

    while(gancho != (struct lista *)0){
        printf("%i \n", gancho->valor);
        gancho = gancho->proximo;
    }

    getchar();
    return 0;
}

inicialmente gancho aponta para m1, que tem o valor 10, depois o gancho vai apontar para proximo, que proximo de m1 aponta para m2
logo o gancho vai apontar pra m2, cujo valor é 20, após printar 20 ele aponta para ganhco->proximo que é um ponteiro para m3.

Aula 09 - Lista Concatenada e Função que retorna Ponteiro - Aula 69

#include <stdio.h>
#include <stdlib.h>
struct lista{
    int valor;
    struct lista *proximo;
    };

//Essa função retorna um endereço de memória struct
struct lista *ProcurarValor(struct lista *pLista, int valor) {
    while (pLista != (struct lista *)0){
        if(pLista->valor == valor){
                return(pLista);

        }else{
            pLista = pLista->proximo;
        }
    }
    return(struct lista *)0;
}

int main()
{
    //Essa função recebe como argumento um endereço de memória de uma struct e um valor inteiro
    struct lista *ProcurarValor(struct lista *pLista, int valor);
    struct lista m1, m2, m3;
    struct lista *resultado, *gancho = &m1;
    int valor;

    m1.valor = 5;
    m2.valor = 10;
    m3.valor = 15;

    m1.proximo = &m2;
    m2.proximo = &m3;
    m3.proximo = 0;

    printf("Digite valor da pesquisa: ");
    scanf("%i", &valor);

    resultado = ProcurarValor(gancho, valor);

    if( resultado == (struct lista *)0){
        printf("Valor nao encontrado. \n");
    }else{
        printf("Valor %i encontrado. \n", resultado->valor);
    }
    system("pause");
    return 0;
}

AULA 10 - Ponteiros e Vetores - Aula 71


o ponteiro quando aponta para um vetor ele não usa []
e oq está sendo apontado não precisa do &
int vetor[3] = {1,2,3};
int *ponteiro = vetor;

No caso, esse ponteiro está apontando para o primeiro membro desse vetor.

    ponteiro = &vetor[2];
    printf("%i\n", *ponteiro);

Essa é outra maneira de apontar um vetor, nesse caso ele está apontando especificamente para aquele membro do vetor
















